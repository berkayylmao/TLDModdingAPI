// clang-format off
//
//   BSD 4-Clause License
//
//   Copyright (c) 2020 Berkay Yigit <berkaytgy@gmail.com>
//   All rights reserved.
//
//   Redistribution and use in source and binary forms, with or without
//   modification, are permitted provided that the following conditions are met:
//   1. Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//   2. Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//   3. All advertising materials mentioning features or use of this software
//      must display the following acknowledgement:
//      This product includes software developed by Berkay Yigit.
//      To support the developer, please donate to:
//      "https://www.paypal.me/berkayylmao".
//   4. Neither the name of "berkayylmao's The Long Dark Mods" nor the
//      names of its contributors may be used to endorse or promote products
//      derived from this software without specific prior written permission.
//
//   THIS SOFTWARE IS PROVIDED BY Berkay Yigit ''AS IS'' AND  ANY EXPRESS OR
//   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//   IN NO EVENT SHALL Berkay Yigit BE LIABLE FOR ANY DIRECT, INDIRECT,
//   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
//   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
//   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// clang-format on

/*
 * Generated by Il2CppTypeDumper (by berkayylmao) on 10:43 02/05/2020 UTC.
 * MIT License
 * Copyright(c) 2020 Berkay Yigit <berkaytgy@gmail.com>
 *
 * A fork of Il2CppDumper (by Perfare)
 * Il2CppDumper license:
 *   MIT License
 *   Copyright(c) 2016 Perfare
 */

#pragma once
#include "Il2CppBase.h"
#include "ModdingAPI.Exposed.UnityEngine.Color.hpp"


namespace ModdingAPI::Exposed::AmplifyBloom {
struct __AmplifyGlare_Il2CppStaticFields {
};

struct __AmplifyGlare_Il2CppVtbl {
  VirtualInvokeData _0_Equals;
  VirtualInvokeData _1_Finalize;
  VirtualInvokeData _2_GetHashCode;
  VirtualInvokeData _3_ToString;
  VirtualInvokeData _4_Destroy;
};

struct __AmplifyGlare_Il2CppClass {
  Il2CppClass_1 _1;
  __AmplifyGlare_Il2CppStaticFields* pStaticFields;
  Il2CppClass_2 _2;
  __AmplifyGlare_Il2CppVtbl vtbl;
};

class AmplifyGlare {
  static constexpr uint64_t                     _rvaClassInstance     = 0x3C8DBA8;
  static inline    __AmplifyGlare_Il2CppClass* _pStaticClassInstance = nullptr;

public:
// Static class getter:
  static inline __AmplifyGlare_Il2CppClass* GetStaticClassInstance() {
    while (!_pStaticClassInstance) {
      Sleep(100);
      auto* ppClassInstance = (__AmplifyGlare_Il2CppClass**)Helpers::Memory::GetInstance().MakeAbsolute(_rvaClassInstance);
      if (ppClassInstance)
        _pStaticClassInstance = *ppClassInstance;
    }
    return _pStaticClassInstance;
  }

  // Il2Cpp fields:
  __AmplifyGlare_Il2CppClass* __pClassInstance;
  void* __monitor;

  // Member fields:
  ModdingAPI::Exposed::AmplifyBloom::GlareDefData_array* m_customGlareDef;
  int32_t m_customGlareDefIdx;
  int32_t m_customGlareDefAmount;
  bool m_applyGlare;
  ModdingAPI::Exposed::UnityEngine::Color _overallTint;
  ModdingAPI::Exposed::UnityEngine::Gradient* m_cromaticAberrationGrad;
  int32_t m_glareMaxPassCount;
  ModdingAPI::Exposed::AmplifyBloom::StarDefData_array* m_starDefArr;
  ModdingAPI::Exposed::AmplifyBloom::GlareDefData_array* m_glareDefArr;
  ModdingAPI::Exposed::UnityEngine::Matrix4x4_array* m_weigthsMat;
  ModdingAPI::Exposed::UnityEngine::Matrix4x4_array* m_offsetsMat;
  ModdingAPI::Exposed::UnityEngine::Color m_whiteReference;
  float m_aTanFoV;
  ModdingAPI::Exposed::AmplifyBloom::AmplifyGlareCache* m_amplifyGlareCache;
  int32_t m_currentWidth;
  int32_t m_currentHeight;
  int32_t m_currentGlareType;
  int32_t m_currentGlareIdx;
  float m_perPassDisplacement;
  float m_intensity;
  float m_overallStreakScale;
  bool m_isDirty;
  ModdingAPI::Exposed::UnityEngine::RenderTexture_array* _rtBuffer;

  // Member methods:
  void ::ctor() {
    reinterpret_cast<void(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*)>(Helpers::Memory::GetInstance().MakeAbsolute(0x1C937F0))(this);
  }
  void Destroy() {
    reinterpret_cast<void(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*)>(Helpers::Memory::GetInstance().MakeAbsolute(0x1C94E80))(this);
  }
  void SetDirty() {
    reinterpret_cast<void(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*)>(Helpers::Memory::GetInstance().MakeAbsolute(0x1C951C0))(this);
  }
  void OnRenderFromCache(ModdingAPI::Exposed::UnityEngine::RenderTexture* source, ModdingAPI::Exposed::UnityEngine::RenderTexture* dest, ModdingAPI::Exposed::UnityEngine::Material* material, float glareIntensity, float cameraRotation) {
    reinterpret_cast<void(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*, ModdingAPI::Exposed::UnityEngine::RenderTexture*, ModdingAPI::Exposed::UnityEngine::RenderTexture*, ModdingAPI::Exposed::UnityEngine::Material*, float, float)>(Helpers::Memory::GetInstance().MakeAbsolute(0x1C951D0))(this, source, dest, material, glareIntensity, cameraRotation);
  }
  void UpdateMatrixesForPass(ModdingAPI::Exposed::UnityEngine::Material* material, ModdingAPI::Exposed::UnityEngine::Vector4_array* offsets, ModdingAPI::Exposed::UnityEngine::Vector4_array* weights, float glareIntensity, float rotation) {
    reinterpret_cast<void(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*, ModdingAPI::Exposed::UnityEngine::Material*, ModdingAPI::Exposed::UnityEngine::Vector4_array*, ModdingAPI::Exposed::UnityEngine::Vector4_array*, float, float)>(Helpers::Memory::GetInstance().MakeAbsolute(0x1C95980))(this, material, offsets, weights, glareIntensity, rotation);
  }
  void OnRenderImage(ModdingAPI::Exposed::UnityEngine::Material* material, ModdingAPI::Exposed::UnityEngine::RenderTexture* source, ModdingAPI::Exposed::UnityEngine::RenderTexture* dest, float cameraRot) {
    reinterpret_cast<void(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*, ModdingAPI::Exposed::UnityEngine::Material*, ModdingAPI::Exposed::UnityEngine::RenderTexture*, ModdingAPI::Exposed::UnityEngine::RenderTexture*, float)>(Helpers::Memory::GetInstance().MakeAbsolute(0x1C95ED0))(this, material, source, dest, cameraRot);
  }
  int32_t get_CurrentGlare() {
    return reinterpret_cast<int32_t(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*)>(Helpers::Memory::GetInstance().MakeAbsolute(0x383AA0))(this);
  }
  void set_CurrentGlare(int32_t value) {
    reinterpret_cast<void(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*, int32_t)>(Helpers::Memory::GetInstance().MakeAbsolute(0x1C975F0))(this, value);
  }
  int32_t get_GlareMaxPassCount() {
    return reinterpret_cast<int32_t(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*)>(Helpers::Memory::GetInstance().MakeAbsolute(0x36D8E0))(this);
  }
  void set_GlareMaxPassCount(int32_t value) {
    reinterpret_cast<void(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*, int32_t)>(Helpers::Memory::GetInstance().MakeAbsolute(0x1C97610))(this, value);
  }
  float get_PerPassDisplacement() {
    return reinterpret_cast<float(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*)>(Helpers::Memory::GetInstance().MakeAbsolute(0x1C97620))(this);
  }
  void set_PerPassDisplacement(float value) {
    reinterpret_cast<void(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*, float)>(Helpers::Memory::GetInstance().MakeAbsolute(0x1C97630))(this, value);
  }
  float get_Intensity() {
    return reinterpret_cast<float(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*)>(Helpers::Memory::GetInstance().MakeAbsolute(0x15F1780))(this);
  }
  void set_Intensity(float value) {
    reinterpret_cast<void(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*, float)>(Helpers::Memory::GetInstance().MakeAbsolute(0x1C97640))(this, value);
  }
  ModdingAPI::Exposed::UnityEngine::Color get_OverallTint() {
    return reinterpret_cast<ModdingAPI::Exposed::UnityEngine::Color(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*)>(Helpers::Memory::GetInstance().MakeAbsolute(0x6F50D0))(this);
  }
  void set_OverallTint(ModdingAPI::Exposed::UnityEngine::Color value) {
    reinterpret_cast<void(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*, ModdingAPI::Exposed::UnityEngine::Color)>(Helpers::Memory::GetInstance().MakeAbsolute(0x1C97670))(this, value);
  }
  bool get_ApplyLensGlare() {
    return reinterpret_cast<bool(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*)>(Helpers::Memory::GetInstance().MakeAbsolute(0x46FCC0))(this);
  }
  void set_ApplyLensGlare(bool value) {
    reinterpret_cast<void(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*, bool)>(Helpers::Memory::GetInstance().MakeAbsolute(0x36D810))(this, value);
  }
  ModdingAPI::Exposed::UnityEngine::Gradient* get_CromaticColorGradient() {
    return reinterpret_cast<ModdingAPI::Exposed::UnityEngine::Gradient*(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*)>(Helpers::Memory::GetInstance().MakeAbsolute(0x319970))(this);
  }
  void set_CromaticColorGradient(ModdingAPI::Exposed::UnityEngine::Gradient* value) {
    reinterpret_cast<void(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*, ModdingAPI::Exposed::UnityEngine::Gradient*)>(Helpers::Memory::GetInstance().MakeAbsolute(0x1C97680))(this, value);
  }
  float get_OverallStreakScale() {
    return reinterpret_cast<float(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*)>(Helpers::Memory::GetInstance().MakeAbsolute(0x1C91720))(this);
  }
  void set_OverallStreakScale(float value) {
    reinterpret_cast<void(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*, float)>(Helpers::Memory::GetInstance().MakeAbsolute(0x1C97690))(this, value);
  }
  ModdingAPI::Exposed::AmplifyBloom::GlareDefData_array* get_CustomGlareDef() {
    return reinterpret_cast<ModdingAPI::Exposed::AmplifyBloom::GlareDefData_array*(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*)>(Helpers::Memory::GetInstance().MakeAbsolute(0x311320))(this);
  }
  void set_CustomGlareDef(ModdingAPI::Exposed::AmplifyBloom::GlareDefData_array* value) {
    reinterpret_cast<void(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*, ModdingAPI::Exposed::AmplifyBloom::GlareDefData_array*)>(Helpers::Memory::GetInstance().MakeAbsolute(0x30D060))(this, value);
  }
  int32_t get_CustomGlareDefIdx() {
    return reinterpret_cast<int32_t(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*)>(Helpers::Memory::GetInstance().MakeAbsolute(0x2FED20))(this);
  }
  void set_CustomGlareDefIdx(int32_t value) {
    reinterpret_cast<void(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*, int32_t)>(Helpers::Memory::GetInstance().MakeAbsolute(0x311090))(this, value);
  }
  int32_t get_CustomGlareDefAmount() {
    return reinterpret_cast<int32_t(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*)>(Helpers::Memory::GetInstance().MakeAbsolute(0x36E9C0))(this);
  }
  void set_CustomGlareDefAmount(int32_t value) {
    reinterpret_cast<void(__fastcall*)(ModdingAPI::Exposed::AmplifyBloom::AmplifyGlare*, int32_t)>(Helpers::Memory::GetInstance().MakeAbsolute(0x1C976A0))(this, value);
  }
};
}